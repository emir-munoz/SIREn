/**
 * Copyright (c) 2009-2012 National University of Ireland, Galway. All Rights Reserved.
 *
 * Project and contact information: http://www.siren.sindice.com/
 *
 * This file is part of the SIREn project.
 *
 * SIREn is a free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * SIREn is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public
 * License along with SIREn. If not, see <http://www.gnu.org/licenses/>.
 */
/**
 * @project siren-benchmark
 * @author Renaud Delbru [ 6 Jul 2012 ]
 * @link http://renaud.delbru.fr/
 */
package org.sindice.siren.benchmark.query;

import java.io.File;
import java.io.IOException;
import java.lang.reflect.Constructor;

import joptsimple.OptionParser;
import joptsimple.OptionSet;

import org.sindice.siren.benchmark.query.provider.QueryProvider;
import org.sindice.siren.benchmark.wrapper.IndexWrapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public abstract class AbstractQueryExecutorCLI {

  protected final OptionParser parser;
  protected OptionSet          opts;

  public static final String       HELP                = "help";

  public static final String       INDEX_WRAPPER       = "index-wrapper";
  public static final String       INDEX_DIRECTORY     = "index-dir";

  public static final String       QUERY_PROVIDER      = "query-provider";
  public static final String       TERM_LEXICON_DIR    = "term-lexicon-dir";
  public static final String       TERMS_SPEC          = "terms-spec";

  public static final String       NB_QUERIES          = "nb-queries";
  public static final String       COLD_CACHE          = "cold-cache";
  public static final String       SEED                = "seed";
  public static final String       THREADS             = "thread";


  protected QueryProvider    queryProvider       = null;
  private IndexWrapper       indexWrapper        = null;
  private File               indexDirectory      = null;
  private boolean            coldCache           = false;
  private final File               resultsDir          = null;
  private int                nThreads            = 1;
  protected int              seed                = 42;

  final Logger logger = LoggerFactory.getLogger(QueryExecutor.class);

  public AbstractQueryExecutorCLI () {
    parser = new OptionParser();
    parser.accepts(HELP, "print this help");
    parser.accepts(INDEX_WRAPPER, "The class of the IndexWrapper to use.")
          .withRequiredArg().ofType(String.class);
    parser.accepts(INDEX_DIRECTORY, "Specify the indexing directory.")
          .withRequiredArg().ofType(File.class);
    parser.accepts(NB_QUERIES, "the number of queries that will be generated by the QueryProvider.")
          .withRequiredArg().ofType(Integer.class).defaultsTo(50);
    parser.accepts(COLD_CACHE, "The cache will be flushed before executing the query.")
          .withRequiredArg().ofType(Boolean.class).defaultsTo(false);
    parser.accepts(SEED, "The seed for generating random keywords")
          .withRequiredArg().ofType(Integer.class);
    parser.accepts(THREADS, "The number of threads for concurrent query execution")
          .withRequiredArg().ofType(Integer.class);
    parser.accepts(QUERY_PROVIDER, "the class of the QueryProvider that will be used.")
          .withRequiredArg().ofType(String.class);
    parser.accepts(TERM_LEXICON_DIR, "The directory where the groups terms files for the Indexed Data are stored.")
          .withRequiredArg().ofType(File.class);
    parser.accepts(TERMS_SPEC, "The specification for the terms in the generated queries, in the format <TermGroups:Occur>+, values seperated by ','.")
          .withRequiredArg().withValuesSeparatedBy(',');
  }

  public final void parseAndExecute(final String[] cmds)
  throws Exception {
    opts = parser.parse(cmds);
    if (opts.has(HELP)) {
      parser.printHelpOn(System.out);
      return;
    }

    if (opts.has(INDEX_DIRECTORY)) {
      try {
        indexDirectory = (File) opts.valueOf(INDEX_DIRECTORY);
      } catch (final Exception e) {
        logger.error("Index directory: " + e.getMessage());
        System.exit(1);
      }
    }
    else {
      logger.error("You have to specify the index directory");
      parser.printHelpOn(System.out);
      System.exit(1);
    }

    if (opts.has(INDEX_WRAPPER)) {
      try {
        final Class clazz = Class.forName((String) opts.valueOf(INDEX_WRAPPER));
        final Constructor<IndexWrapper> ct = clazz.getConstructors()[0];
        indexWrapper = ct.newInstance(indexDirectory);
      } catch (final Exception e) {
        logger.error("The IndexWrapper class could not be instanciated.", e);
        System.exit(1);
      }
    }

    // Cold Cache
    coldCache = (Boolean) opts.valueOf(COLD_CACHE);

    // TermLexiconReader seed
    if (opts.has(SEED)) {
      seed = (Integer) opts.valueOf(SEED);
    }

    // Number of threads
    if (opts.has(THREADS)) {
      nThreads = (Integer) opts.valueOf(THREADS);
    }

    // get query provider
    queryProvider = this.getQueryProvider();

    // Number of queries
    if (opts.has(NB_QUERIES)) {
      queryProvider.setNbQueries((Integer) opts.valueOf(NB_QUERIES));
    }


    final AbstractQueryExecutor qe;
    if (nThreads == 1) {
      qe = new QueryExecutor(indexWrapper, queryProvider);
      ((QueryExecutor) qe).setColdCache(coldCache);
    }
    else {
      qe = new ConcurrentQueryExecutor(indexWrapper, queryProvider, nThreads);
    }
    // Execute the benchmark
    qe.execute();

    // Export results
    if (resultsDir != null) {
      qe.exportHits(resultsDir);
      qe.exportQueryTimes(resultsDir);
      qe.exportMeasurementTimes(resultsDir);
      qe.exportQueryRates(resultsDir);
    }
    // close resources
    qe.close();
    indexWrapper.close();
    queryProvider.close();
  }

  protected abstract QueryProvider getQueryProvider() throws IOException;

}
